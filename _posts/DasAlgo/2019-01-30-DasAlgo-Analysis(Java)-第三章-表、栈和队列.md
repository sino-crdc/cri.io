---
layout: post
title: DasAlgo-Analysis(Java) 第三章 表、栈和队列
categories: DasAlgo
tags: DasAlgo
---

### 第三章 表、栈和队列

1. ADT 抽象数据类型
2. A_i 后继 A_{i-1}, A_{i-1} 前驱 A_i, 前驱元和后继元。
3. 表的实现：简单数组实现和链表实现。
- 链表的每个节点包括表元素和链(next链)。
- 双链表
4. Collections API:
- Collection<T> extends Iterable<T>
- Iterable: remove()删除由next()最新返回的项
- 使用Iterable.remove()的两重原因
	- 知道删除项的准确位置，效率更高。
	- 针对 ConcurrentModificationException 的保护机制。
- List ADT 的两种实现方式：ArrayList 和 LinkedList
	- ArrayList 是可增长数组实现
	- LinkedList 是双链表实现
	- ArrayList 的数据域 ensureCapacity 和 trimToSize() 方法
5. 示例：remove方法对LinkedList的应用：删除偶数值项
- 优化一：避免拷贝
- 优化二：get方法改为迭代器
6. 泛型数组的创建是违法的，不可避免地：创建泛型类型限界地数组之后采用类型转换。
7. 内部类、嵌套类的区分在于是否静态。
8. 示例：迭代器优化
- 初始：MyArrayList 和 ArrayListIterator 是平行的类：迭代器无法使用表的数据
- 优化一：迭代器构造时传入表对象：表的数据域的可见性问题
- 优化二：嵌套类：编译器无法计算得出迭代所针对的表的对象
- 优化三：内部类
9. 当声明一个内部类时，编译器则添加对外部类对象的一个**隐式引用**，该对象引起内部类对象的构造。
10. 在每一个内部类的对象都恰好与外部类对象的一个实例相关联的情况下，内部类是有用的。在这种情况下，内部类的对象在没有外部类对象与其关联时是永远不可能存在的。
11. 链表：标记节点（头节点，尾节点）属于额外节点。
12. 链表实现的启示：
> 返回boolean类型判断操作是否成功。<br>
> doClear()方法和clear()方法的分离。<br>
> 嵌套类(静态内部类)和内部类(非静态)的使用情境区别：是否必须绑定特定的外部类对象。<br>
> modCount检测机制：检测迭代器内部更改次数和外部表的更改次数。<br>
> 代码的合并简化。<br>
> 私有内部类/嵌套类数据域的公开性无关紧要。<br>
> 错误检测机制：状态变量机制(用于迭代器是否可用remove()方法的判断，前有next()状态为true，否则为false)<br>
13. 栈是限制插入和从删除操作只能在一个位置进行的表，该位置叫做栈顶，基本操作是：top(),push(),pop().栈有时也叫做LIFO(后进先出)表。
14. 由于栈是一个表，所以任何实现表的方法都能够实现栈。通常使用：数组实现和单链表实现。
15. 空栈的topOfStack为-1.
16. 最现代化的计算机将栈操作作为它的指令系统的一部分，所以栈很可能是计算机科学中在数组之后的最基本的数据结构。
17. 栈操作通常是O(N)的联机算法.
18. 栈ADT的应用：
* 平衡符号
* 后缀表达式
* 方法调用
19. 平衡符号：用于编译检测代码中的成对符号：做一个空栈，读入字符直到文件尾。如果字符是一个开放字符，则将其推入栈中。如果字符是一个封闭符号，则当栈空时报错。否则将栈元素弹出，如果弹出的符号不是对应的开发符号，则报错。在文件尾，如果栈非空，则报错。
20. 后缀表达式：[实例和代码实现的链接](https://www.cnblogs.com/hantalk/p/8734511.html)
* 计算式的后缀记法或称作逆波兰记法。使用这种记法没有必要知道任何优先级原则。
* 中缀表达式向后缀表达式的转换<br>
1）如果遇到操作数，我们就直接将其输出。<br>
2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。<br>
3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。注意，左括号只弹出并不输出。<br>
4）如果遇到任何其他的操作符，如（“+”， “\*”，“（”）等，从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止。弹出完这些元素后，才将遇到的操作符压入到栈中。有一点需要注意，只有在遇到" ) "的情况下我们才弹出" ( "，其他情况我们都不会弹出" ( "。<br>
5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。<br>
* 上述仅仅包含从左到右结合的操作符和括号，但不包含从右到左的操作符如取幂运算。
21. 方法调用：[《再谈方法调用和堆栈》的链接](https://blog.csdn.net/u010454030/article/details/84186053)
* 相关概念：主调例程，当前位置，寄存器，活动记录(栈帧)，尾递归
* 方法调用和方法返回基本上类似于开括号和闭括号。
* 当前环境是由栈顶描述的。
* 在实际计算机种的栈常常是从内存分区的高端向下增长。
* 尾递归：在return中调用递归，理论上，尾递归总能够使用非递归方式。而且，尾递归需要比正常递归存储更多的信息(调用例程的局部变量和地址)。
22. 队列ADT: FIFO表。基本操作是enqueue()和dequeue(),数据域是队头rear和队尾front(或有队长)
23. 队列和栈一样，有链表实现和数组实现两种方式。
24. 队列链表实现较简单，数组实现存在问题(front不在数组的起始位置，而rear已经超出数组长度)，采用的解决方案是**循环数组**实现。
25. 循环数组：将超出数组的队尾回绕至数组起始端.
26. 队列的应用：排队论的模拟与分析。
27. 表、栈和队列是计算机科学中三个基本的数据结构。

Written by [ZenMoore](https://github.com/ZenMoore "Github")<br>
2/3/2019 20:22:54 PM 